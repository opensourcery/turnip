#!/bin/bash

##
# @file
# OpenSourcery Drupal Deployment Script
#
# @todo This currently won't work for initial deployment to a Drupal
# host. Several things still need to be done manually the first time
# around--creating directory structure: releases, shared/files,
# modifying/uploading settings.php

# Change $SUBDOMAIN accordingly, e.g. <mountain name>
# Rather than set $USER, use the user we were run as.
SUBDOMAIN=
HOST=gargravarr
DOCUMENTROOT=/var/www/$SUBDOMAIN

# Branch to deploy from
BRANCH=.

# Set FRONTPAGE if you want to turn on recursive response testing.
#
# This setting is used for testing the success of the deployment, and
# should be of the form:
#
#   http://example.org
#
# Note, if the site forces either www. or removes it, then the
# non-redirect version should be used. For example, if all requests
# are redirected from http://example.org to http://www.example.org,
# then this variable should be set to http://www.example.org

# FRONTPAGE=http://$SUBDOMAIN.opensourcery.com

# How deep to follow links.
TESTINGLEVEL=6

##### Things below here generally won't need to be changed #####

# If SUBDOMAIN isn't set, DOCUMENTROOT would become /var/www// and we'd blow
# away the permissions of every test host on the test server.
if [ -z "$SUBDOMAIN" ]; then
  echo "ERROR: You must set SUBDOMAIN (within $0) before running this script."
  exit
fi

if [ ! -d ./drupal ]; then
  echo "ERROR: ./drupal directory does not exist; nothing to deploy."
  exit
fi

TIMESTAMP=`date +%Y_%m_%d__%H_%M_%S`

# A bit hacky: rsync everything up by *temporarily* making us the owner of everything.

ssh $USER@$HOST "sudo chown -R $USER.$USER $DOCUMENTROOT" || {
  echo "ERROR: Check your test host username versus your local username. If they're different, run as 'USER=mytesthostusername $0'";
  exit;
}

# Values below here shouldn't need to be modified for standard OS Drupal deployments

# Add -L to copy symlinks' referent files, so that we'll bring along our install profile
rsync -LazC --exclude=sites/all/files --exclude=sites/default/files --exclude=sites/default/settings.php --exclude=backup $BRANCH/drupal/ /tmp/$TIMESTAMP/

# Create links to settings and files.
# NOTE: This is done locally, prior to upload, even though locally
# they are broken links.
chmod 777 /tmp/$TIMESTAMP/sites/default
ln -s $DOCUMENTROOT/shared/files /tmp/$TIMESTAMP/sites/default/files
ln -s $DOCUMENTROOT/shared/settings.php /tmp/$TIMESTAMP/sites/default/settings.php

ssh $USER@$HOST cp -Rp $DOCUMENTROOT/current/ $DOCUMENTROOT/releases/$TIMESTAMP
rsync -azC --delete /tmp/$TIMESTAMP/ $USER@$HOST:$DOCUMENTROOT/releases/$TIMESTAMP/

ssh -t $USER@$HOST "find $DOCUMENTROOT -type d -exec chmod 750 {} +"
ssh -t $USER@$HOST "find $DOCUMENTROOT -type f -exec chmod 640 {} +"
ssh -t $USER@$HOST "find $DOCUMENTROOT/shared/files -type d -exec chmod 770 {} +"
ssh -t $USER@$HOST "find $DOCUMENTROOT/shared/files -type f -exec chmod 660 {} +"

# remove old release link and link the new version
ssh $USER@$HOST rm $DOCUMENTROOT/current
ssh $USER@$HOST ln -s $DOCUMENTROOT/releases/$TIMESTAMP $DOCUMENTROOT/current

# Change owner and group back to Apache
ssh $USER@$HOST sudo chown -R www-data.www-data $DOCUMENTROOT

echo "Deployment complete"
rm -Rf /tmp/$TIMESTAMP
echo "Cleaned up local machine's /tmp/$TIMESTAMP"

# Perform recursive tests, saving log to a file. The downloaded files are immediately deleted.
if [[ ! -z "$FRONTPAGE" ]]; then
  RESPONSE_LOG=$TIMESTAMP.wget.tests.txt
  RESPONSE_OUTPUT=$TIMESTAMP.wget.output.html

  echo "Starting response testing"
  cd /tmp
  wget --verbose --recursive --level=$TESTINGLEVEL -nd --delete-after -o /tmp/$RESPONSE_LOG -O /tmp/$RESPONSE_OUTPUT $FRONTPAGE
  cd -

  # Test for 404 errors
  echo "404 errors:"
  grep HTTP -B3 /tmp/$RESPONSE_LOG | egrep "HTTP|--[0-9]{2}" | egrep "HTTP.*404" -B1
  # Test for 403 errors
  echo "403 errors:"
  grep HTTP -B3 /tmp/$RESPONSE_LOG | egrep "HTTP|--[0-9]{2}" | egrep "HTTP.*403" -B1
  # Test for non-standard responses
  echo "Other responses (other than 200, 404 and 403:"
  grep HTTP /tmp/$RESPONSE_LOG | grep -v 200 | grep -v 404 | grep -v 403
  echo "To review, see /tmp/$RESPONSE_LOG"
  # End of response testing

  # Find parse errors
  echo "Checking for Parse Errors:"
  parse_errors=`egrep '<b>Parse error</b>:.*</b> on line <b>[0-9]+</b>' /tmp/$RESPONSE_OUTPUT | wc -l`
  if [ $parse_errors -gt 0 ];
  then
    echo "Found $parse_errors parse errors! See /tmp/$RESPONSE_OUTPUT for details."
    exit
  else
    echo "No parse errors found."
  fi

  # Find fatal errors
  echo "Checking for Fatal Errors:"
  fatal_errors=`egrep '<b>Fatal error</b>:.*</b> on line <b>[0-9]+</b>' /tmp/$RESPONSE_OUTPUT | wc -l`
  if [ $fatal_errors -gt 0 ];
  then
    echo "Found $fatal_errors fatal errors! See /tmp/$RESPONSE_OUTPUT for details."
    exit
  else
    echo "No fatal errors found."
  fi
fi


